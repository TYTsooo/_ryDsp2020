<!DOCTYPE html>
<!-- saved from url=(0055)http://greenteapress.com/thinkdsp/html/thinkdsp012.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">

<meta name="generator" content="hevea 2.09">
<link rel="stylesheet" type="text/css" href="./Modulation and sampling_files/thinkdsp.css">
<title>Modulation and sampling</title>
<style id="dark-reader-style" type="text/css">@media screen {

/* Leading rule */
html {
  -webkit-filter: invert(100%) hue-rotate(180deg) brightness(110%) contrast(90%) grayscale(20%) sepia(10%) !important;
  filter: invert(100%) hue-rotate(180deg) brightness(110%) contrast(90%) grayscale(20%) sepia(10%) !important;
}

/* Reverse rule */
img,
video,
:not(object):not(body)>embed,
object,
svg image,
[style*="background:url"],
[style*="background-image:url"],
[style*="background: url"],
[style*="background-image: url"],
[background],
twitterwidget {
  -webkit-filter: invert(100%) hue-rotate(180deg) !important;
  filter: invert(100%) hue-rotate(180deg) !important;
}
[style*="background:url"] *,
[style*="background-image:url"] *,
[style*="background: url"] *,
[style*="background-image: url"] *,
input,
[background] *,
img[src^="https://s0.wp.com/latex.php"],
twitterwidget .NaturalImage-image {
  -webkit-filter: none !important;
  filter: none !important;
}
.compatibility-with-darkreader-below-4-3-3 {
  background: white !important;
}

/* Text contrast */
html {
  text-shadow: 0 0 0 !important;
}

/* Full screen */
:-webkit-full-screen, :-webkit-full-screen * {
  -webkit-filter: none !important;
  filter: none !important;
}
:-moz-full-screen, :-moz-full-screen * {
  -webkit-filter: none !important;
  filter: none !important;
}
:fullscreen, :fullscreen * {
  -webkit-filter: none !important;
  filter: none !important;
}

/* Page background */
html {
  background: rgb(13,13,12) !important;
}

/* Custom rules */
.compatibility-with-darkreader-below-4-3-3 {
    background: white !important;
}

}</style></head>
<body class="">
<a href="http://greenteapress.com/thinkdsp/html/thinkdsp011.html"><img src="./Modulation and sampling_files/back.png" alt="Previous"></a>
<a href="http://greenteapress.com/thinkdsp/html/index.html"><img src="./Modulation and sampling_files/up.png" alt="Up"></a>
<a href="http://greenteapress.com/thinkdsp/html/thinkdsp013.html"><img src="./Modulation and sampling_files/next.png" alt="Next"></a>
<hr>
<table>

<tbody><tr>

<td valign="top" width="100" bgcolor="#b53f97">
</td>

<td valign="top" width="600" style="padding: 20px 20px;">

<p>This HTML version of is provided for convenience, but it
is not the best format for the book.  In particular, some of the
symbols are not rendered correctly.

</p><p>You might prefer to read
the <a href="http://greenteapress.com/thinkdsp/thinkdsp.pdf">PDF version</a>.

</p><p>
<a href="http://amzn.to/1T8U0mR">You can buy this book at Amazon.</a>
</p><h1 class="chapter" id="sec89"><span class="c003">Chapter&nbsp;11&nbsp;&nbsp;Modulation and sampling</span></h1>
<p><span class="c003">In Section&nbsp;</span><a href="http://greenteapress.com/thinkdsp/html/thinkdsp003.html#aliasing"><span class="c003">2.3</span></a><span class="c003"> we saw that when a signal is sampled at
10,000 Hz, a component at 5500 Hz is indistinguishable from a
component at 4500 Hz. In this example, the folding frequency, 5000 Hz,
is half of the sampling rate. But I didn’t explain why.
</span><a id="hevea_default420"></a></p><p><span class="c003">This chapter explores the effect of sampling and presents the
Sampling Theorem, which explains aliasing and the folding frequency.
</span><a id="hevea_default421"></a><span class="c003">
</span><a id="hevea_default422"></a></p><p><span class="c003">I’ll start by exploring the effect of convolution with impulses;
I’ll use that effect to explain amplitude modulation (AM), which
turns out to be useful for understanding the Sampling Theorem.</span></p><p><span class="c003">The code for this chapter is in </span><span class="c003"><span class="c002">chap11.ipynb</span></span><span class="c003">, which is in the
repository for this book (see Section&nbsp;</span><a href="http://greenteapress.com/thinkdsp/html/thinkdsp001.html#code"><span class="c003">0.2</span></a><span class="c003">).
You can also view it at </span><a href="http://tinyurl.com/thinkdsp-ch11"><span class="c003"><span class="c002">http://tinyurl.com/thinkdsp-ch11</span></span></a><span class="c003">.</span></p><span class="c003">
</span><h2 class="section" id="sec90"><span class="c003">11.1&nbsp;&nbsp;Convolution with impulses</span></h2>
<p><span class="c003">As we saw in Section&nbsp;</span><a href="http://greenteapress.com/thinkdsp/html/thinkdsp011.html#sysconv"><span class="c003">10.4</span></a><span class="c003">, convolution of a signal with
a series of impulses has the effect of adding up shifted, scaled
copies of the signal.
</span><a id="hevea_default423"></a><span class="c003">
</span><a id="hevea_default424"></a></p><p><span class="c003">As an example, I’ll read a signal that sounds like a beep:</span></p><pre class="verbatim"><span class="c003">filename = '253887__themusicalnomad__positive-beeps.wav'
wave = thinkdsp.read_wave(filename)
wave.normalize()
</span></pre><p><span class="c003">And I’ll construct a wave with four impulses:</span></p><pre class="verbatim"><span class="c003">imp_sig = thinkdsp.Impulses([0.005, 0.3, 0.6,  0.9], 
                       amps=[1,     0.5, 0.25, 0.1])
impulses = imp_sig.make_wave(start=0, duration=1.0, 
                             framerate=wave.framerate)
</span></pre><p><span class="c003">And then convolve them:</span></p><pre class="verbatim"><span class="c003">convolved = wave.convolve(impulses)
</span></pre><blockquote class="figure"><div class="center"><hr class="c015"></div><span class="c003">
</span><div class="center"><span class="c003"><img src="./Modulation and sampling_files/thinkdsp062.png"></span></div><span class="c003">
</span><div class="caption"><table class="c000 cellpading0"><tbody><tr><td class="c014"><span class="c003">Figure 11.1: The effect of convolving a signal (top left) with a series of
impulses (bottom left). The result (right) is the sum of shifted,
scaled copies of the signal.</span></td></tr>
</tbody></table></div><span class="c003">
</span><a id="fig.sampling1"></a><span class="c003">
</span><div class="center"><hr class="c015"></div></blockquote><p><span class="c003">Figure&nbsp;</span><a href="http://greenteapress.com/thinkdsp/html/thinkdsp012.html#fig.sampling1"><span class="c003">11.1</span></a><span class="c003"> shows the results, with the signal in
the top left, the impulses in the lower left, and the result on
the right.</span></p><p><span class="c003">You can hear the result in </span><span class="c003"><span class="c002">chap11.ipynb</span></span><span class="c003">; it sounds like
a series of four beeps with decreasing loudness.</span></p><p><span class="c003">The point of this example is just to demonstrate that convolution
with impulses makes shifted, scaled copies. This result will be
useful in the next section.
</span><a id="hevea_default425"></a><span class="c003">
</span><a id="hevea_default426"></a></p><span class="c003">
</span><h2 class="section" id="sec91"><span class="c003">11.2&nbsp;&nbsp;Amplitude modulation</span></h2>
<p><span class="c003">
</span><a id="am"></a></p><blockquote class="figure"><div class="center"><hr class="c015"></div><span class="c003">
</span><div class="center"><span class="c003"><img src="./Modulation and sampling_files/thinkdsp063.png"></span></div><span class="c003">
</span><div class="caption"><table class="c000 cellpading0"><tbody><tr><td class="c014"><span class="c003">Figure 11.2: Demonstration of amplitude modulation. The top row is the
spectrum of the signal; the next row is the spectrum after modulation;
the next row is the spectrum after demodulation; the last row is the
demodulated signal after low-pass filtering.</span></td></tr>
</tbody></table></div><span class="c003">
</span><a id="fig.sampling2"></a><span class="c003">
</span><div class="center"><hr class="c015"></div></blockquote><p><span class="c003">Amplitude modulation (AM) is used to broadcast AM radio, among other
applications. At the transmitter, the signal (which might contain
speech, music, etc.) is “modulated” by multiplying it with a cosine
signal that acts as a “carrier wave”. The result is a
high-frequency wave that is suitable for broadcast by radio. Typical
frequencies for AM radio in the United States are 500–1600 kHz (see
</span><a href="https://en.wikipedia.org/wiki/AM_broadcasting"><span class="c003"><span class="c002">https://en.wikipedia.org/wiki/AM_broadcasting</span></span></a><span class="c003">).
</span><a id="hevea_default427"></a><span class="c003">
</span><a id="hevea_default428"></a><span class="c003">
</span><a id="hevea_default429"></a></p><p><span class="c003">At the receiving end, the broadcast signal is “demodulated” to
recover the original signal. Surprisingly, demodulation works by
multiplying the broadcast signal, again, by the same carrier wave.
</span><a id="hevea_default430"></a></p><p><span class="c003">To see how that works, I’ll modulate a signal with a carrier wave at
10 kHz. Here’s the signal:
</span><a id="hevea_default431"></a></p><pre class="verbatim"><span class="c003">filename = '105977__wcfl10__favorite-station.wav'
wave = thinkdsp.read_wave(filename)
wave.unbias()
wave.normalize()
</span></pre><p><span class="c003">And here’s the carrier:</span></p><pre class="verbatim"><span class="c003">carrier_sig = thinkdsp.CosSignal(freq=10000)
carrier_wave = carrier_sig.make_wave(duration=wave.duration, 
                                     framerate=wave.framerate)
</span></pre><p><span class="c003">We can multiply them using the </span><span class="c003"><span class="c002">*</span></span><span class="c003"> operator, which multiplies
the wave arrays elementwise:</span></p><pre class="verbatim"><span class="c003">modulated = wave * carrier_wave
</span></pre><p><span class="c003">The result sounds pretty bad. You can hear it in </span><span class="c003"><span class="c002">chap11.ipynb</span></span><span class="c003">.</span></p><p><span class="c003">Figure&nbsp;</span><a href="http://greenteapress.com/thinkdsp/html/thinkdsp012.html#fig.sampling2"><span class="c003">11.2</span></a><span class="c003"> shows what’s happening in the frequency
domain. The top row is the spectrum of the original signal. The
next row is the spectrum of the modulated signal, after multiplying
by the carrier. It contains two copies of the original spectrum,
shifted by plus and minus 10 kHz.
</span><a id="hevea_default432"></a></p><p><span class="c003">To understand why, recall that convolution in the time domain corresponds
to multiplication in the frequency domain. Conversely, multiplication
in the time domain corresponds to convolution in the frequency domain.
When we multiply the signal by the carrier, we are convolving its
spectrum with the DFT of the carrier.
</span><a id="hevea_default433"></a></p><p><span class="c003">Since the carrier is a simple cosine wave, its DFT is two impulses, at
plus and minus 10 kHz. Convolution with these impulses makes
shifted, scaled copies of the spectrum. Notice that the amplitude of
the spectrum is smaller after modulation. The energy from the original
signal is split between the copies.
</span><a id="hevea_default434"></a></p><p><span class="c003">We demodulate the signal, by multiplying by the carrier wave again:</span></p><pre class="verbatim"><span class="c003">demodulated = modulated * carrier_wave
</span></pre><p><span class="c003">The third row of Figure&nbsp;</span><a href="http://greenteapress.com/thinkdsp/html/thinkdsp012.html#fig.sampling2"><span class="c003">11.2</span></a><span class="c003"> shows the result. Again,
multiplication in the time domain corresponds to convolution in the
frequency domain, which makes shifted, scaled copies of the spectrum.</span></p><p><span class="c003">Since the modulated spectrum contains two peaks, each peak gets split
in half and shifted by plus and minus 20 kHz. Two of the copies
meet at 0 kHz and get added together; the other two copies end up
centered at plus and minus 20 kHz.</span></p><p><span class="c003">If you listen to the demodulated signal, it sounds pretty good. The
extra copies of the spectrum add high frequency components that were
not in the original signal, but they are so high that most speakers
can’t play them and most people can’t hear them. But if
you have good speakers and good ears, you might.</span></p><p><span class="c003">In that case, you can get rid of the extra components by applying a
low-pass filter:
</span><a id="hevea_default435"></a></p><pre class="verbatim"><span class="c003">demodulated_spectrum = demodulated.make_spectrum(full=True)
demodulated_spectrum.low_pass(10000)
filtered = demodulated_spectrum.make_wave()
</span></pre><p><span class="c003">The result is quite close to the original wave, although about half
of the power is lost after demodulating and filtering. That’s not
a problem in practice, because much more of the power is lost in
transmitting and receiving the broadcast signal. Since we have to amplify
the result anyway, another factor of 2 is not an issue.</span></p><span class="c003">
</span><h2 class="section" id="sec92"><span class="c003">11.3&nbsp;&nbsp;Sampling</span></h2>
<blockquote class="figure"><div class="center"><hr class="c015"></div><span class="c003">
</span><div class="center"><span class="c003"><img src="./Modulation and sampling_files/thinkdsp064.png"></span></div><span class="c003">
</span><div class="caption"><table class="c000 cellpading0"><tbody><tr><td class="c014"><span class="c003">Figure 11.3: Spectrum of a signal before (top) and after (bottom) sampling.</span></td></tr>
</tbody></table></div><span class="c003">
</span><a id="fig.sampling3"></a><span class="c003">
</span><div class="center"><hr class="c015"></div></blockquote><p><span class="c003">I explained amplitude modulation in part because it is interesting, but
mostly because it will help us understand sampling. “Sampling” is
the process of measuring an analog signal at a series of points in
time, usually with equal spacing.
</span><a id="hevea_default436"></a></p><p><span class="c003">For example, the WAV files we have used as examples were
recorded by sampling the output of a microphone using an analog-to-digital
converter (ADC). The sampling rate for most of them is 44.1 kHz,
which is the standard rate for “CD quality” sound, or 48 kHz, which
is the standard for DVD sound.
</span><a id="hevea_default437"></a><span class="c003">
</span><a id="hevea_default438"></a></p><p><span class="c003">At 48 kHz, the folding frequency is 24 kHz, which is higher than most
people can hear (see </span><a href="https://en.wikipedia.org/wiki/Hearing_range"><span class="c003"><span class="c002">https://en.wikipedia.org/wiki/Hearing_range</span></span></a><span class="c003">).</span></p><p><span class="c003">In most of these waves, each sample has 16 bits, so there
are </span><span class="c003">2</span><sup><span class="c003">16</span></sup><span class="c003"> distinct levels. This “bit depth” turns out to be enough
that adding more bits does not improve the sound quality noticeably
(see </span><a href="https://en.wikipedia.org/wiki/Digital_audio"><span class="c003"><span class="c002">https://en.wikipedia.org/wiki/Digital_audio</span></span></a><span class="c003">).
</span><a id="hevea_default439"></a></p><p><span class="c003">Of course, applications other than audio signals might require higher
sampling rates in order to capture higher frequencies, or higher
bit-depth in order to reproduce waveforms with more fidelity.</span></p><p><span class="c003">To demonstrate the effect of the sampling process, I am going to start
with a wave sampled at 44.1 kHz and select samples from it at about 11 kHz.
This is not exactly the same as sampling from an analog signal, but
the effect is the same.</span></p><p><span class="c003">First I’ll load a recording of a drum solo:</span></p><pre class="verbatim"><span class="c003">filename = '263868__kevcio__amen-break-a-160-bpm.wav'
wave = thinkdsp.read_wave(filename)
wave.normalize()
</span></pre><p><span class="c003">Figure&nbsp;</span><a href="http://greenteapress.com/thinkdsp/html/thinkdsp012.html#fig.sampling3"><span class="c003">11.3</span></a><span class="c003"> (top) shows the spectrum of this wave.
Now here’s the function that samples from the wave:</span></p><pre class="verbatim"><span class="c003">def sample(wave, factor=4):
    ys = np.zeros(len(wave))
    ys[::factor] = wave.ys[::factor]
    return thinkdsp.Wave(ys, framerate=wave.framerate)
</span></pre><p><span class="c003">I’ll use it to select every fourth element:</span></p><pre class="verbatim"><span class="c003">sampled = sample(wave, 4)
</span></pre><p><span class="c003">The result has the same frame rate as the original, but most of the
elements are zero. If you play the sampled wave, it doesn’t sound
very good. The sampling process introduces high-frequency
components that were not in the original.</span></p><p><span class="c003">Figure&nbsp;</span><a href="http://greenteapress.com/thinkdsp/html/thinkdsp012.html#fig.sampling3"><span class="c003">11.3</span></a><span class="c003"> (bottom) shows the spectrum of the sampled
wave. It contains four copies of the original spectrum (it looks like
five copies because one is split between the highest and lowest
frequencies).
</span><a id="hevea_default440"></a></p><blockquote class="figure"><div class="center"><hr class="c015"></div><span class="c003">
</span><div class="center"><span class="c003"><img src="./Modulation and sampling_files/thinkdsp065.png"></span></div><span class="c003">
</span><div class="caption"><table class="c000 cellpading0"><tbody><tr><td class="c014"><span class="c003">Figure 11.4: The DFT of an impulse train is also an impulse train.</span></td></tr>
</tbody></table></div><span class="c003">
</span><a id="fig.sampling9"></a><span class="c003">
</span><div class="center"><hr class="c015"></div></blockquote><p><span class="c003">To understand where these copies come from, we can think of the
sampling process as multiplication with a series of impulses. Instead
of using </span><span class="c003"><span class="c002">sample</span></span><span class="c003"> to select every fourth element, we could use
this function to make a series of impulses, sometimes called an
</span><span class="c003"><span class="c007">impulse train</span></span><span class="c003">:
</span><a id="hevea_default441"></a></p><pre class="verbatim"><span class="c003">def make_impulses(wave, factor):
    ys = np.zeros(len(wave))
    ys[::factor] = 1
    ts = np.arange(len(wave)) / wave.framerate
    return thinkdsp.Wave(ys, ts, wave.framerate)
</span></pre><p><span class="c003">And then multiply the original wave by the impulse train:</span></p><pre class="verbatim"><span class="c003">impulses = make_impulses(wave, 4)
sampled = wave * impulses
</span></pre><p><span class="c003">The result is the same; it still doesn’t sound very good, but now
we understand why. Multiplication in the time domain corresponds
to convolution in the frequency domain. When we multiply
by an impulse train, we are convolving with the DFT of an
impulse train. As it turns out, the DFT of an impulse
train is also an impulse train. </span></p><p><span class="c003">Figure&nbsp;</span><a href="http://greenteapress.com/thinkdsp/html/thinkdsp012.html#fig.sampling9"><span class="c003">11.4</span></a><span class="c003"> shows two examples. The top row is
the impulse train in the example, with frequency 11,025 Hz.
The DFT is a train of 4 impulses, which is why we get 4 copies
of the spectrum. The bottom row shows an impulse
train with a lower frequency, about 5512 Hz. Its DFT is a train
of 8 impulses. In general, more impulses in the time
domain correspond to fewer impulses in the frequency
domain.</span></p><p><span class="c003">In summary:</span></p><ul class="itemize"><li class="li-itemize"><span class="c003">We can think of sampling as multiplication by an impulse train.</span></li><li class="li-itemize"><span class="c003">Multiplying by an impulse train corresponds
to convolution with an impulse train in the frequency domain.</span></li><li class="li-itemize"><span class="c003">Convolution with an impulse train makes multiple copies of the
signal’s spectrum.</span></li></ul><span class="c003">
</span><h2 class="section" id="sec93"><span class="c003">11.4&nbsp;&nbsp;Aliasing</span></h2>
<blockquote class="figure"><div class="center"><hr class="c015"></div><span class="c003">
</span><div class="center"><span class="c003"><img src="./Modulation and sampling_files/thinkdsp066.png"></span></div><span class="c003">
</span><div class="caption"><table class="c000 cellpading0"><tbody><tr><td class="c014"><span class="c003">Figure 11.5: Spectrum of the drum solo (top), spectrum of the impulse
train (second row), spectrum of the sampled wave (third row),
after low-pass filtering (bottom).</span></td></tr>
</tbody></table></div><span class="c003">
</span><a id="fig.sampling4"></a><span class="c003">
</span><div class="center"><hr class="c015"></div></blockquote><p><span class="c003">In Section&nbsp;</span><a href="http://greenteapress.com/thinkdsp/html/thinkdsp012.html#am"><span class="c003">11.2</span></a><span class="c003">, after demodulating an AM signal, we got rid of
the extra copies of the spectrum by applying a low-pass filter.
We can do the same thing after sampling, but it turns out
not to be a perfect solution.</span></p><p><span class="c003">Figure&nbsp;</span><a href="http://greenteapress.com/thinkdsp/html/thinkdsp012.html#fig.sampling4"><span class="c003">11.5</span></a><span class="c003"> shows why not. The top row is the spectrum
of the drum solo. It contains high frequency components that extend
past 10 kHz. When we sample this wave, we convolve the spectrum 
with the impulse train (second row), which makes copies of the spectrum
(third row). The bottom row shows the result after applying a low-pass
filter with a cutoff at the folding frequency, 5512 Hz.</span></p><p><span class="c003">If we convert the result back to a wave, it is similar to the original
wave, but there are two problems:</span></p><ul class="itemize"><li class="li-itemize"><span class="c003">Because of the low-pass filter, the components above 5500 Hz
have been lost, so the result sounds muted.</span></li><li class="li-itemize"><span class="c003">Even the components below 5500 Hz are not quite right, because
they include contributions from the spectral copies we
tried to filter out.</span></li></ul><blockquote class="figure"><div class="center"><hr class="c015"></div><span class="c003">
</span><div class="center"><span class="c003"><img src="./Modulation and sampling_files/thinkdsp067.png"></span></div><span class="c003">
</span><div class="caption"><table class="c000 cellpading0"><tbody><tr><td class="c014"><span class="c003">Figure 11.6: Spectrum of a bass guitar solo (top), its spectrum after
sampling (middle), and after filtering (bottom).</span></td></tr>
</tbody></table></div><span class="c003">
</span><a id="fig.sampling5"></a><span class="c003">
</span><div class="center"><hr class="c015"></div></blockquote><p><span class="c003">If the spectral copies overlap after sampling, we lose information
about the spectrum and we won’t be able to recover it.</span></p><p><span class="c003">But if the copies don’t overlap, things work out pretty well. As
a second example, I loaded a recording of a bass guitar solo. </span></p><p><span class="c003">Figure&nbsp;</span><a href="http://greenteapress.com/thinkdsp/html/thinkdsp012.html#fig.sampling5"><span class="c003">11.6</span></a><span class="c003"> shows its spectrum (top row), which contains
no visible energy above 5512 Hz. The second row shows the spectrum of
the sampled wave, and the third row shows the spectrum after the low
pass filter. The amplitude is lower because we’ve filtered out some
of the energy, but the shape of the spectrum is almost exactly what we
started with. And if we convert back to a wave, it sounds the same.</span></p><span class="c003">
</span><h2 class="section" id="sec94"><span class="c003">11.5&nbsp;&nbsp;Interpolation</span></h2>
<blockquote class="figure"><div class="center"><hr class="c015"></div><span class="c003">
</span><div class="center"><span class="c003"><img src="./Modulation and sampling_files/thinkdsp068.png"></span></div><span class="c003">
</span><div class="caption"><table class="c000 cellpading0"><tbody><tr><td class="c014"><span class="c003">Figure 11.7: A brick wall low-pass filter (right) and the corresponding
convolution window (left).</span></td></tr>
</tbody></table></div><span class="c003">
</span><a id="fig.sampling6"></a><span class="c003">
</span><div class="center"><hr class="c015"></div></blockquote><p><span class="c003">The low-pass filter I used in the last step is a so-called </span><span class="c003"><span class="c007">brick
wall filter</span></span><span class="c003">; frequencies above the cutoff are removed completely,
as if they hit a brick wall.
</span><a id="hevea_default442"></a></p><p><span class="c003">Figure&nbsp;</span><a href="http://greenteapress.com/thinkdsp/html/thinkdsp012.html#fig.sampling6"><span class="c003">11.7</span></a><span class="c003"> (right) shows what this filter looks like.
Of course, multiplication by this filter in the frequency domain
corresponds to convolution with a window in the time domain. We can
find out what that window is by computing the inverse DFT of the
filter, which is shown in Figure&nbsp;</span><a href="http://greenteapress.com/thinkdsp/html/thinkdsp012.html#fig.sampling6"><span class="c003">11.7</span></a><span class="c003"> (left).</span></p><p><span class="c003">That function has a name; it is the normalized </span><span class="c003"><span class="c007">sinc function</span></span><span class="c003">, or at
least a discrete approximation of it (see
</span><a href="https://en.wikipedia.org/wiki/Sinc_function"><span class="c003"><span class="c002">https://en.wikipedia.org/wiki/Sinc_function</span></span></a><span class="c003">):
</span></p><table class="display dcenter"><tbody><tr class="c013"><td class="dcell"><span class="c003"><span class="c006">sinc</span></span><span class="c003">(</span><span class="c003"><span class="c006">x</span></span><span class="c003">)&nbsp;=&nbsp;</span></td><td class="dcell"><table class="display"><tbody><tr><td class="dcell c008"><span class="c003">sin</span><span class="c003">&#960;&nbsp;</span><span class="c003"><span class="c006">x</span></span></td></tr>
<tr><td class="hbar"><span class="c003"></span></td></tr>
<tr><td class="dcell c008"><span class="c003">&#960;&nbsp;</span><span class="c003"><span class="c006">x</span></span></td></tr>
</tbody></table></td><td class="dcell"><span class="c003">&nbsp;</span></td></tr>
</tbody></table><p><span class="c003">
When we apply the low-pass filter, we are convolving with a sinc
function. We can think of this convolution as the sum of shifted,
scaled copies of the sinc function. 
</span><a id="hevea_default443"></a><span class="c003">
</span><a id="hevea_default444"></a></p><p><span class="c003">The value of sinc is 1 at 0 and 0 at every other integer
value of </span><span class="c003"><span class="c006">x</span></span><span class="c003">. When we shift the sinc function, we move the zero point.
When we scale it, we change the height at the zero point.
So when we add up the shifted, scaled copies, they interpolate
between the sampled points.</span></p><blockquote class="figure"><div class="center"><hr class="c015"></div><span class="c003">
</span><div class="center"><span class="c003"><img src="./Modulation and sampling_files/thinkdsp069.png"></span></div><span class="c003">
</span><div class="caption"><table class="c000 cellpading0"><tbody><tr><td class="c014"><span class="c003">Figure 11.8: Close up view of a sequence of samples (vertical gray lines),
interpolating sinc functions (thin curves), and the original
wave (thicker line across the top).</span></td></tr>
</tbody></table></div><span class="c003">
</span><a id="fig.sampling8"></a><span class="c003">
</span><div class="center"><hr class="c015"></div></blockquote><p><span class="c003">Figure&nbsp;</span><a href="http://greenteapress.com/thinkdsp/html/thinkdsp012.html#fig.sampling8"><span class="c003">11.8</span></a><span class="c003"> shows how that works using a short segment
of the bass guitar solo. The line across the top is the original
wave. The vertical gray lines show the sampled values. The thin
curves are the shifted, scaled copies of the sinc function.
The sum of these sinc functions is identical to the original wave.</span></p><p><span class="c003">I’ll say that again, because it is surprising and important:</span></p><blockquote class="quote"><span class="c003">
The sum of these sinc functions is identical to the original wave.
</span></blockquote><p><span class="c003">Because we started with a signal that contained no energy
above 5512 Hz, and we sampled at 11,025 Hz, we were able to recover
the original spectrum exactly. And if we have the original spectrum,
exactly, we can recover the original wave exactly.</span></p><p><span class="c003">In this example, I started with a wave that had already been
sampled at 44,100 Hz, and I resampled it at 11,025 Hz. After
resampling, the gap between the spectral copies is 11.025 kHz.</span></p><p><span class="c003">If the original wave contains no
energy above 5512 Hz, the spectral copies don’t overlap, we don’t lose
information, and we can recover the original signal exactly.</span></p><p><span class="c003">This result is known as the Nyquist-Shannon sampling theorem (see 
</span><a href="https://en.wikipedia.org/wiki/Nyquist-Shannon_sampling_theorem"><span class="c003"><span class="c002">https://en.wikipedia.org/wiki/Nyquist-Shannon_sampling_theorem</span></span></a><span class="c003">).
</span><a id="hevea_default445"></a><span class="c003">
</span><a id="hevea_default446"></a><span class="c003">
</span><a id="hevea_default447"></a></p><p><span class="c003">This example does not prove the Sampling Theorem, but I hope it
helps you understand what it says and why it works.</span></p><p><span class="c003">Notice that the argument I made does
not depend on the original sampling rate, 44.1 kHz. The result
would be the same if the original had been sampled at a higher
frequency, or even if the original had been a continuous analog
signal: if we sample at frame rate </span><span class="c003"><span class="c006">f</span></span><span class="c003">, we can recover the original
signal exactly, as long as it contains no energy at frequencies
above </span><span class="c003"><span class="c006">f</span></span><span class="c003">/2</span><span class="c003">. A signal like that is called </span><span class="c003"><span class="c007">bandwidth limited</span></span><span class="c003">.</span></p><span class="c003">
</span><h2 class="section" id="sec95"><span class="c003">11.6&nbsp;&nbsp;Summary</span></h2>
<p><span class="c003">Congratulations! You have reached the end of the book (well, except
for a few more exercises). Before you close the book, I want to review
how we got here:</span></p><ul class="itemize"><li class="li-itemize"><span class="c003">We started with periodic signals and their spectrums, and I
introduced the key objects in the </span><span class="c003"><span class="c002">thinkdsp</span></span><span class="c003"> library: Signal, Wave, and
Spectrum.</span></li><li class="li-itemize"><span class="c003">We looked at the harmonic structure of simple waveforms and
recordings of musical instruments, and we saw the effect of aliasing.</span></li><li class="li-itemize"><span class="c003">Using spectrograms, we explored chirps and other sounds whose
spectrum changes over time.</span></li><li class="li-itemize"><span class="c003">We generated and analyzed noise signals, and characterized natural
sources of noise.</span></li><li class="li-itemize"><span class="c003">We used the autocorrelation function for pitch estimation and
additional characterization of noise.</span></li><li class="li-itemize"><span class="c003">We learned about the Discrete Cosine Transform (DCT), which is
useful for compression and also a step toward understanding
the Discrete Fourier Transform (DFT).</span></li><li class="li-itemize"><span class="c003">We used complex exponentials to synthesize complex signals, then
we inverted the process to develop the DFT. If you did the exercises
at the end of the chapter, you implemented the Fast Fourier Transform,
one of the most important algorithms of the 20th century.</span></li><li class="li-itemize"><span class="c003">Starting with smoothing, I presented the definition of convolution
and stated the Convolution Theorem, which relates operations like smoothing
in the time domain to filters in the frequency domain.</span></li><li class="li-itemize"><span class="c003">We explored differentiation and integration as linear filters,
which is the basis of spectral methods for solving differential equations.
It also explains some of the effects we saw in previous chapters, like
the relationship between white noise and Brownian noise.</span></li><li class="li-itemize"><span class="c003">We learned about LTI system theory and used the
Convolution Theorem to characterize LTI systems by their
impulse response.</span></li><li class="li-itemize"><span class="c003">I presented amplitude modulation (AM), which is important in
radio communication and also a step toward understanding the
Sampling Theorem, a surprising result that is critical for digital
signal processing.</span></li></ul><p><span class="c003">If you got this far, you should have a good balance of practical
knowledge – how to work with signals and spectrums using computational
tools – and theory – an understanding of how and why sampling and
filtering work.</span></p><p><span class="c003">I hope you had some fun along the way. Thank you!</span></p><span class="c003">
</span><h2 class="section" id="sec96"><span class="c003">11.7&nbsp;&nbsp;Exercises</span></h2>
<p><span class="c003">Solutions to these exercises are in </span><span class="c003"><span class="c002">chap11soln.ipynb</span></span><span class="c003">.</span></p><div class="theorem"><span class="c003"><span class="c007">Exercise&nbsp;1</span></span><span class="c003">&nbsp;&nbsp;<em>
The code in this chapter is in </em></span><span class="c003"><em><span class="c002">chap11.ipynb</span></em></span><span class="c003"><em>. Read through
it and listen to the examples.
</em></span></div><div class="theorem"><span class="c003"><span class="c007">Exercise&nbsp;2</span></span><span class="c003">&nbsp;&nbsp;<em>
Chris “Monty” Montgomery has an excellent video called “D/A and A/D
| Digital Show and Tell”; it demonstrates the Sampling Theorem in
action, and presents lots of other excellent information about
sampling. Watch it at
</em></span><a href="https://www.youtube.com/watch?v=cIQ9IXSUzuM"><span class="c003"><em><span class="c002">https://www.youtube.com/watch?v=cIQ9IXSUzuM</span></em></span></a><span class="c003"><em>.</em></span><p><a id="hevea_default448"></a><span class="c003"><em>
</em></span><a id="hevea_default449"></a></p></div><div class="theorem"><span class="c003"><span class="c007">Exercise&nbsp;3</span></span><span class="c003">&nbsp;&nbsp;<em>
As we have seen, if you sample a signal at too low a
frame rate, frequencies above the folding frequency get aliased.
Once that happens, it is no longer possible to filter out
these components, because they are indistinguishable from
lower frequencies.
</em></span><a id="hevea_default450"></a><p><span class="c003"><em>It is a good idea to filter out these frequencies </em></span><span class="c003">before</span><span class="c003"><em>
sampling; a low-pass filter used for this purpose is called
an </em></span><span class="c003"><em><span class="c007">anti-aliasing filter</span></em></span><span class="c003"><em>.
</em></span><a id="hevea_default451"></a></p><p><span class="c003"><em>Returning to the drum solo example, apply a low-pass filter
before sampling, then apply the low-pass filter again to remove
the spectral copies introduced by sampling. The result should
be identical to the filtered signal.
</em></span></p></div></td>

<td width="130" valign="top">

<p>
</p><h4>Are you using one of our books in a class?</h4>  We'd like to know
about it.  Please consider filling out <a href="http://spreadsheets.google.com/viewform?formkey=dC0tNUZkMjBEdXVoRGljNm9FRmlTMHc6MA" onclick="javascript: pageTracker._trackPageview(&#39;/outbound/survey&#39;);">this short survey</a>.

<p>
<br>

</p><p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491938455/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1491938455&amp;linkCode=as2&amp;tag=greenteapre01-20&amp;linkId=2JJH4SWCAVVYSQHO">Think DSP</a><img class="c001" src="./Modulation and sampling_files/ir" width="1" height="1" border="0" alt="">

</p><p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491938455/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1491938455&amp;linkCode=as2&amp;tag=greenteapre01-20&amp;linkId=CTV7PDT7E5EGGJUM"><img border="0" src="./Modulation and sampling_files/q"></a><img class="c001" src="./Modulation and sampling_files/ir" width="1" height="1" border="0" alt="">

</p><p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491929561/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1491929561&amp;linkCode=as2&amp;tag=greenteapre01-20&amp;linkId=ZY6MAYM33ZTNSCNZ">Think Java</a><img class="c001" src="./Modulation and sampling_files/ir(1)" width="1" height="1" border="0" alt="">

</p><p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491929561/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1491929561&amp;linkCode=as2&amp;tag=greenteapre01-20&amp;linkId=PT77ANWARUNNU3UK"><img border="0" src="./Modulation and sampling_files/q(1)"></a><img class="c001" src="./Modulation and sampling_files/ir(1)" width="1" height="1" border="0" alt="">

</p><p>
<a href="http://www.amazon.com/gp/product/1449370780/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1449370780&amp;linkCode=as2&amp;tag=greenteapre01-20">Think Bayes</a><img class="c001" src="./Modulation and sampling_files/ir(2)" width="1" height="1" border="0" alt="">

</p><p>
<a href="http://www.amazon.com/gp/product/1449370780/ref=as_li_qf_sp_asin_il?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1449370780&amp;linkCode=as2&amp;tag=greenteapre01-20"><img border="0" src="./Modulation and sampling_files/q(2)"></a><img class="c001" src="./Modulation and sampling_files/ir(2)" width="1" height="1" border="0" alt="">

</p><p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491939362/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1491939362&amp;linkCode=as2&amp;tag=greenteapre01-20&amp;linkId=FJKSQ3IHEMY2F2VA">Think Python 2e</a><img class="c001" src="./Modulation and sampling_files/ir(3)" width="1" height="1" border="0" alt="">


</p><p>
<a rel="nofollow" href="http://www.amazon.com/gp/product/1491939362/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1491939362&amp;linkCode=as2&amp;tag=greenteapre01-20&amp;linkId=ZZ454DLQ3IXDHNHX"><img border="0" src="./Modulation and sampling_files/q(3)"></a><img class="c001" src="./Modulation and sampling_files/ir(3)" width="1" height="1" border="0" alt="">

</p><p>
<a href="http://www.amazon.com/gp/product/1491907339/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1491907339&amp;linkCode=as2&amp;tag=greenteapre01-20&amp;linkId=O7WYM6H6YBYUFNWU">Think Stats 2e</a><img class="c001" src="./Modulation and sampling_files/ir(4)" width="1" height="1" border="0" alt="">

</p><p>
<a href="http://www.amazon.com/gp/product/1491907339/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1491907339&amp;linkCode=as2&amp;tag=greenteapre01-20&amp;linkId=JVSYKQHYSUIEYRHL"><img border="0" src="./Modulation and sampling_files/q(4)"></a><img class="c001" src="./Modulation and sampling_files/ir(4)" width="1" height="1" border="0" alt="">

</p><p>
<a href="http://www.amazon.com/gp/product/1449314635/ref=as_li_tf_tl?ie=UTF8&amp;tag=greenteapre01-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1449314635">Think Complexity</a><img class="c001" src="./Modulation and sampling_files/ir(5)" width="1" height="1" border="0" alt="">

</p><p>
<a href="http://www.amazon.com/gp/product/1449314635/ref=as_li_tf_il?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1449314635&amp;linkCode=as2&amp;tag=greenteapre01-20"><img border="0" src="./Modulation and sampling_files/q(5)"></a><img class="c001" src="./Modulation and sampling_files/ir(5)" width="1" height="1" border="0" alt="">


</p></td>
</tr>
</tbody></table>


<hr>
<a href="http://greenteapress.com/thinkdsp/html/thinkdsp011.html"><img src="./Modulation and sampling_files/back.png" alt="Previous"></a>
<a href="http://greenteapress.com/thinkdsp/html/index.html"><img src="./Modulation and sampling_files/up.png" alt="Up"></a>
<a href="http://greenteapress.com/thinkdsp/html/thinkdsp013.html"><img src="./Modulation and sampling_files/next.png" alt="Next"></a>


<iframe frameborder="0" scrolling="no" style="background-color: transparent; border: 0px; display: none;" src="./Modulation and sampling_files/saved_resource.html"></iframe><div id="GOOGLE_INPUT_CHEXT_FLAG" style="display: none;" input="" input_stat="{&quot;tlang&quot;:true,&quot;tsbc&quot;:true,&quot;pun&quot;:true,&quot;mk&quot;:true,&quot;ss&quot;:true}"></div><div id="speechnotesx_mirror_container"><div id="speechnotesx_mirror"></div></div></body></html>